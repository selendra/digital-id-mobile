"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Subscription = void 0;
const tslib_1 = require("tslib");
const events_1 = require("events");
const types_1 = require("@walletconnect/types");
const constants_1 = require("../constants");
const pino_utils_1 = require("@pedrouid/pino-utils");
class Subscription extends types_1.ISubscription {
    constructor(client, logger, context, encrypted) {
        super(client, logger, context, encrypted);
        this.client = client;
        this.logger = logger;
        this.context = context;
        this.encrypted = encrypted;
        this.subscriptions = new Map();
        this.events = new events_1.EventEmitter();
        this.cached = [];
        this.logger = pino_utils_1.generateChildLogger(logger, this.context);
        this.registerEventListeners();
    }
    init() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.trace(`Initialized`);
            yield this.restore();
        });
    }
    get length() {
        return this.subscriptions.size;
    }
    get topics() {
        return Array.from(this.subscriptions.keys());
    }
    get values() {
        return Array.from(this.subscriptions.values());
    }
    set(topic, data, opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.isEnabled();
            if (this.subscriptions.has(topic)) {
                this.update(topic, data);
            }
            else {
                this.logger.debug(`Setting subscription`);
                this.logger.trace({ type: "method", method: "set", topic, data, opts });
                if (this.encrypted && typeof opts.decryptKeys === "undefined") {
                    const errorMessage = `Decrypt params required for ${this.getSubscriptionContext()}`;
                    this.logger.error(errorMessage);
                    throw new Error(errorMessage);
                }
                yield this.subscribeAndSet(topic, data, opts);
                this.events.emit(constants_1.SUBSCRIPTION_EVENTS.created, {
                    topic,
                    data,
                });
            }
        });
    }
    get(topic) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.isEnabled();
            this.logger.debug(`Getting subscription`);
            this.logger.trace({ type: "method", method: "get", topic });
            const subscription = yield this.getSubscription(topic);
            return subscription.data;
        });
    }
    update(topic, update) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.isEnabled();
            this.logger.debug(`Updating subscription`);
            this.logger.trace({ type: "method", method: "update", topic, update });
            const subscription = yield this.getSubscription(topic);
            const data = Object.assign(Object.assign({}, subscription.data), update);
            this.subscriptions.set(topic, Object.assign(Object.assign({}, subscription), { topic,
                data }));
            this.events.emit(constants_1.SUBSCRIPTION_EVENTS.updated, {
                topic,
                data,
                update,
            });
        });
    }
    delete(topic, reason) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.isEnabled();
            this.logger.debug(`Deleting subscription`);
            this.logger.trace({ type: "method", method: "delete", topic, reason });
            const subscription = yield this.getSubscription(topic);
            this.subscriptions.delete(topic);
            yield this.client.relayer.unsubscribe(subscription.id, {
                relay: subscription.opts.relay,
                decryptKeys: subscription.opts.decryptKeys,
            });
            this.events.emit(constants_1.SUBSCRIPTION_EVENTS.deleted, {
                topic,
                data: subscription.data,
                reason,
            });
        });
    }
    on(event, listener) {
        this.events.on(event, listener);
    }
    once(event, listener) {
        this.events.once(event, listener);
    }
    off(event, listener) {
        this.events.off(event, listener);
    }
    removeListener(event, listener) {
        this.events.removeListener(event, listener);
    }
    onPayload(payloadEvent) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.events.emit(constants_1.SUBSCRIPTION_EVENTS.payload, payloadEvent);
        });
    }
    getNestedContext(length) {
        const nestedContext = pino_utils_1.getLoggerContext(this.logger).split("/");
        return nestedContext.slice(nestedContext.length - length, nestedContext.length);
    }
    getSubscriptionContext() {
        return this.getNestedContext(2).join(" ");
    }
    getStorageKey() {
        const storageKeyPrefix = `${this.client.protocol}@${this.client.version}:${this.client.context}`;
        const subscriptionContext = this.getNestedContext(2).join(":");
        return `${storageKeyPrefix}//${subscriptionContext}`;
    }
    getSubscription(topic) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.isEnabled();
            const subscription = this.subscriptions.get(topic);
            if (!subscription) {
                const errorMessage = `No matching ${this.getSubscriptionContext()} with topic: ${topic}`;
                this.logger.error(errorMessage);
                throw new Error(errorMessage);
            }
            return subscription;
        });
    }
    subscribeAndSet(topic, data, opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const id = yield this.client.relayer.subscribe(topic, (payload) => this.onPayload({ topic, payload }), opts);
            this.subscriptions.set(topic, { id, topic, data, opts });
        });
    }
    persist() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.client.storage.setItem(this.getStorageKey(), this.values);
        });
    }
    restore() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const persisted = yield this.client.storage.getItem(this.getStorageKey());
                if (typeof persisted === "undefined")
                    return;
                if (!persisted.length)
                    return;
                if (this.subscriptions.size) {
                    const errorMessage = `Restore will override already set ${this.getSubscriptionContext()}`;
                    this.logger.error(errorMessage);
                    throw new Error(errorMessage);
                }
                this.cached = persisted;
                yield Promise.all(this.cached.map((subscription) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    const { topic, data, opts } = subscription;
                    yield this.subscribeAndSet(topic, data, opts);
                })));
                yield this.enable();
                this.logger.debug(`Successfully Restored subscriptions for ${this.getSubscriptionContext()}`);
                this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
            }
            catch (e) {
                this.logger.debug(`Failed to Restore subscriptions for ${this.getSubscriptionContext()}`);
                this.logger.error(e);
            }
        });
    }
    reset() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.disable();
            yield Promise.all(this.cached.map((subscription) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const { topic, data, opts } = subscription;
                yield this.subscribeAndSet(topic, data, opts);
            })));
            yield this.enable();
        });
    }
    isEnabled() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.cached.length)
                return;
            return new Promise(resolve => {
                this.events.once("enabled", () => resolve());
            });
        });
    }
    enable() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.cached = [];
            this.events.emit("enabled");
        });
    }
    disable() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.cached.length) {
                this.cached = this.values;
            }
            this.events.emit("disabled");
        });
    }
    registerEventListeners() {
        this.client.relayer.on("connect", () => this.reset());
        this.events.on(constants_1.SUBSCRIPTION_EVENTS.payload, (payloadEvent) => {
            this.logger.info(`Emitting ${constants_1.SUBSCRIPTION_EVENTS.created}`);
            this.logger.debug({ type: "event", event: constants_1.SUBSCRIPTION_EVENTS.created, data: payloadEvent });
        });
        this.events.on(constants_1.SUBSCRIPTION_EVENTS.created, (createdEvent) => {
            this.logger.info(`Emitting ${constants_1.SUBSCRIPTION_EVENTS.created}`);
            this.logger.debug({ type: "event", event: constants_1.SUBSCRIPTION_EVENTS.created, data: createdEvent });
            this.persist();
        });
        this.events.on(constants_1.SUBSCRIPTION_EVENTS.updated, (updatedEvent) => {
            this.logger.info(`Emitting ${constants_1.SUBSCRIPTION_EVENTS.updated}`);
            this.logger.debug({ type: "event", event: constants_1.SUBSCRIPTION_EVENTS.updated, data: updatedEvent });
            this.persist();
        });
        this.events.on(constants_1.SUBSCRIPTION_EVENTS.deleted, (deletedEvent) => {
            this.logger.info(`Emitting ${constants_1.SUBSCRIPTION_EVENTS.updated}`);
            this.logger.debug({ type: "event", event: constants_1.SUBSCRIPTION_EVENTS.updated, data: deletedEvent });
            this.persist();
        });
    }
}
exports.Subscription = Subscription;
//# sourceMappingURL=subscription.js.map