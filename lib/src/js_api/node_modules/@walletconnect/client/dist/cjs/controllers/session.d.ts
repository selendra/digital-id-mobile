/// <reference types="node" />
import { EventEmitter } from "events";
import { Logger } from "pino";
import { IClient, ISession, SessionTypes, SubscriptionEvent } from "@walletconnect/types";
import { JsonRpcPayload } from "@json-rpc-tools/utils";
import { Subscription } from "./subscription";
import { JsonRpcHistory } from "./history";
export declare class Session extends ISession {
    client: IClient;
    logger: Logger;
    pending: Subscription<SessionTypes.Pending>;
    settled: Subscription<SessionTypes.Settled>;
    history: JsonRpcHistory;
    events: EventEmitter;
    protected context: string;
    constructor(client: IClient, logger: Logger);
    init(): Promise<void>;
    get(topic: string): Promise<SessionTypes.Settled>;
    ping(topic: string): Promise<void>;
    send(topic: string, payload: JsonRpcPayload, chainId?: string): Promise<void>;
    get length(): number;
    get topics(): string[];
    get values(): SessionTypes.Settled[];
    create(params: SessionTypes.CreateParams): Promise<SessionTypes.Settled>;
    respond(params: SessionTypes.RespondParams): Promise<SessionTypes.Pending>;
    update(params: SessionTypes.UpdateParams): Promise<SessionTypes.Settled>;
    request(params: SessionTypes.RequestParams): Promise<any>;
    delete(params: SessionTypes.DeleteParams): Promise<void>;
    notify(params: SessionTypes.NotifyParams): Promise<void>;
    on(event: string, listener: any): void;
    once(event: string, listener: any): void;
    off(event: string, listener: any): void;
    removeListener(event: string, listener: any): void;
    protected propose(params: SessionTypes.ProposeParams): Promise<SessionTypes.Pending>;
    protected settle(params: SessionTypes.SettleParams): Promise<SessionTypes.Settled>;
    protected onResponse(payloadEvent: SubscriptionEvent.Payload): Promise<void>;
    protected onAcknowledge(payloadEvent: SubscriptionEvent.Payload): Promise<void>;
    protected onMessage(payloadEvent: SubscriptionEvent.Payload): Promise<void>;
    protected onPayload(payloadEvent: SubscriptionEvent.Payload): Promise<void>;
    protected onUpdate(payloadEvent: SubscriptionEvent.Payload): Promise<void>;
    protected handleUpdate(session: SessionTypes.Settled, params: SessionTypes.UpdateParams, participant: {
        publicKey: string;
    }): Promise<SessionTypes.Update>;
    protected onNotification(event: SubscriptionEvent.Payload): Promise<void>;
    private shouldIgnorePayloadEvent;
    private onPayloadEvent;
    private onPendingPayloadEvent;
    private onPendingStatusEvent;
    private registerEventListeners;
}
//# sourceMappingURL=session.d.ts.map