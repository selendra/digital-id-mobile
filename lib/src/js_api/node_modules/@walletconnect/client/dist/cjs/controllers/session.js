"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Session = void 0;
const tslib_1 = require("tslib");
const events_1 = require("events");
const pino_utils_1 = require("@pedrouid/pino-utils");
const types_1 = require("@walletconnect/types");
const utils_1 = require("@walletconnect/utils");
const utils_2 = require("@json-rpc-tools/utils");
const subscription_1 = require("./subscription");
const history_1 = require("./history");
const constants_1 = require("../constants");
class Session extends types_1.ISession {
    constructor(client, logger) {
        super(client, logger);
        this.client = client;
        this.logger = logger;
        this.events = new events_1.EventEmitter();
        this.context = constants_1.SESSION_CONTEXT;
        this.logger = pino_utils_1.generateChildLogger(logger, this.context);
        this.pending = new subscription_1.Subscription(client, this.logger, constants_1.SESSION_STATUS.pending, true);
        this.settled = new subscription_1.Subscription(client, this.logger, constants_1.SESSION_STATUS.settled, true);
        this.history = new history_1.JsonRpcHistory(client, this.logger);
        this.registerEventListeners();
    }
    init() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.trace(`Initialized`);
            yield this.pending.init();
            yield this.settled.init();
            yield this.history.init();
        });
    }
    get(topic) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.settled.get(topic);
        });
    }
    ping(topic) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const request = { method: constants_1.SESSION_JSONRPC.ping, params: {} };
            return this.request({ topic, request });
        });
    }
    send(topic, payload, chainId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const session = yield this.settled.get(topic);
            const encryptKeys = {
                sharedKey: session.sharedKey,
                publicKey: session.self.publicKey,
            };
            if (utils_2.isJsonRpcRequest(payload)) {
                if (!Object.values(constants_1.SESSION_JSONRPC).includes(payload.method)) {
                    if (!session.permissions.jsonrpc.methods.includes(payload.method)) {
                        const errorMessage = `Unauthorized JSON-RPC Method Requested: ${payload.method}`;
                        this.logger.error(errorMessage);
                        throw new Error(errorMessage);
                    }
                    yield this.history.set(topic, payload, chainId);
                    payload = utils_2.formatJsonRpcRequest(constants_1.SESSION_JSONRPC.payload, {
                        chainId,
                        request: { method: payload.method, params: payload.params },
                    }, payload.id);
                }
            }
            else {
                yield this.history.update(topic, payload);
            }
            yield this.client.relayer.publish(session.topic, payload, {
                relay: session.relay,
                encryptKeys,
            });
        });
    }
    get length() {
        return this.settled.length;
    }
    get topics() {
        return this.settled.topics;
    }
    get values() {
        return this.settled.values.map(x => x.data);
    }
    create(params) {
        return new Promise((resolve, reject) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.info(`Create Session`);
            this.logger.trace({ type: "method", method: "create", params });
            const timeout = setTimeout(() => {
                const errorMessage = `Session failed to settle after 30 seconds`;
                this.logger.error(errorMessage);
                reject(errorMessage);
            }, 30000);
            let pending;
            try {
                pending = yield this.propose(params);
            }
            catch (e) {
                clearTimeout(timeout);
                return reject(e);
            }
            this.pending.on(constants_1.SUBSCRIPTION_EVENTS.updated, (updatedEvent) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (pending.topic !== updatedEvent.data.topic)
                    return;
                if (utils_1.isSessionResponded(updatedEvent.data)) {
                    const outcome = updatedEvent.data.outcome;
                    clearTimeout(timeout);
                    if (utils_1.isSessionFailed(outcome)) {
                        try {
                            yield this.pending.delete(pending.topic, outcome.reason);
                        }
                        catch (e) {
                            return reject(e);
                        }
                        reject(new Error(outcome.reason));
                    }
                    else {
                        try {
                            const pairing = yield this.settled.get(outcome.topic);
                            yield this.pending.delete(pending.topic, constants_1.SESSION_REASONS.settled);
                            resolve(pairing);
                        }
                        catch (e) {
                            return reject(e);
                        }
                    }
                }
            }));
        }));
    }
    respond(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.info(`Respond Session`);
            this.logger.trace({ type: "method", method: "respond", params });
            const paramsValidation = utils_1.validateSessionRespondParams(params);
            if (utils_1.isValidationInvalid(paramsValidation)) {
                throw new Error(paramsValidation.error);
            }
            const { approved, proposal, response } = params;
            const { relay } = proposal;
            const self = utils_1.generateKeyPair();
            const pairing = yield this.client.pairing.get(proposal.signal.params.topic);
            const decryptKeys = {
                sharedKey: pairing.sharedKey,
            };
            if (approved) {
                try {
                    const responder = {
                        publicKey: self.publicKey,
                        metadata: response.metadata,
                    };
                    const expiry = Date.now() + proposal.ttl;
                    const state = {
                        accounts: params.response.state.accounts,
                    };
                    const session = yield this.settle({
                        relay,
                        self,
                        peer: proposal.proposer,
                        permissions: formatSettledPermissions(proposal.permissions, self.publicKey),
                        ttl: proposal.ttl,
                        expiry,
                        state,
                    });
                    const outcome = {
                        topic: session.topic,
                        relay: session.relay,
                        state: session.state,
                        responder,
                        expiry,
                    };
                    const pending = {
                        status: constants_1.SESSION_STATUS.responded,
                        topic: proposal.topic,
                        relay: proposal.relay,
                        self,
                        proposal,
                        outcome,
                    };
                    yield this.pending.set(pending.topic, pending, { relay: pending.relay, decryptKeys });
                    return pending;
                }
                catch (e) {
                    const reason = e.message;
                    const outcome = { reason };
                    const pending = {
                        status: constants_1.SESSION_STATUS.responded,
                        topic: proposal.topic,
                        relay: proposal.relay,
                        self,
                        proposal,
                        outcome,
                    };
                    yield this.pending.set(pending.topic, pending, { relay: pending.relay, decryptKeys });
                    return pending;
                }
            }
            else {
                const outcome = { reason: constants_1.SESSION_REASONS.not_approved };
                const pending = {
                    status: constants_1.SESSION_STATUS.responded,
                    topic: proposal.topic,
                    relay: proposal.relay,
                    self,
                    proposal,
                    outcome,
                };
                yield this.pending.set(pending.topic, pending, { relay: pending.relay, decryptKeys });
                return pending;
            }
        });
    }
    update(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.info(`Update Session`);
            this.logger.trace({ type: "method", method: "update", params });
            const session = yield this.settled.get(params.topic);
            const update = yield this.handleUpdate(session, params, {
                publicKey: session.self.publicKey,
            });
            const request = utils_2.formatJsonRpcRequest(constants_1.SESSION_JSONRPC.update, update);
            yield this.send(session.topic, request);
            return session;
        });
    }
    request(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const request = utils_2.formatJsonRpcRequest(params.request.method, params.request.params);
                const timeout = setTimeout(() => {
                    const errorMessage = `JSON-RPC Request timeout after 30s: ${request.method}`;
                    this.logger.error(errorMessage);
                    reject(errorMessage);
                }, 30000);
                this.events.on(constants_1.SESSION_EVENTS.payload, (payloadEvent) => {
                    if (params.topic !== payloadEvent.topic)
                        return;
                    if (utils_2.isJsonRpcRequest(payloadEvent.payload))
                        return;
                    const response = payloadEvent.payload;
                    if (response.id !== request.id)
                        return;
                    clearTimeout(timeout);
                    if (utils_2.isJsonRpcError(response)) {
                        const errorMessage = response.error.message;
                        this.logger.error(errorMessage);
                        return reject(new Error(errorMessage));
                    }
                    return resolve(response.result);
                });
                try {
                    yield this.send(params.topic, request, params.chainId);
                }
                catch (e) {
                    clearTimeout(timeout);
                    return reject(e);
                }
            }));
        });
    }
    delete(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.info(`Delete Session`);
            this.logger.trace({ type: "method", method: "delete", params });
            this.settled.delete(params.topic, params.reason);
        });
    }
    notify(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const session = yield this.settled.get(params.topic);
            if (session.self.publicKey !== session.permissions.notifications.controller.publicKey &&
                !session.permissions.notifications.types.includes(params.type)) {
                const errorMessage = `Unauthorized Notification Type Requested: ${params.type}`;
                this.logger.error(errorMessage);
                throw new Error(errorMessage);
            }
            const notification = { type: params.type, data: params.data };
            const request = utils_2.formatJsonRpcRequest(constants_1.SESSION_JSONRPC.notification, notification);
            yield this.send(params.topic, request);
        });
    }
    on(event, listener) {
        this.events.on(event, listener);
    }
    once(event, listener) {
        this.events.once(event, listener);
    }
    off(event, listener) {
        this.events.off(event, listener);
    }
    removeListener(event, listener) {
        this.events.removeListener(event, listener);
    }
    propose(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.info(`Propose Session`);
            this.logger.trace({ type: "method", method: "propose", params });
            const paramsValidation = utils_1.validateSessionProposeParams(params);
            if (utils_1.isValidationInvalid(paramsValidation)) {
                throw new Error(paramsValidation.error);
            }
            if (params.signal.method !== constants_1.SESSION_SIGNAL_METHOD_PAIRING) {
                throw new Error(`Session proposal signal unsupported`);
            }
            const pairing = yield this.client.pairing.settled.get(params.signal.params.topic);
            const signal = {
                method: constants_1.SESSION_SIGNAL_METHOD_PAIRING,
                params: { topic: pairing.topic },
            };
            const decryptKeys = {
                sharedKey: pairing.sharedKey,
            };
            const topic = utils_1.generateRandomBytes32();
            const self = utils_1.generateKeyPair();
            const proposer = {
                publicKey: self.publicKey,
                metadata: params.metadata,
            };
            const proposal = {
                topic,
                relay: params.relay,
                proposer,
                signal,
                permissions: params.permissions,
                ttl: params.ttl || constants_1.SESSION_DEFAULT_TTL,
            };
            const pending = {
                status: constants_1.SESSION_STATUS.proposed,
                topic: proposal.topic,
                relay: proposal.relay,
                self,
                proposal,
            };
            yield this.pending.set(pending.topic, pending, { relay: pending.relay, decryptKeys });
            return pending;
        });
    }
    settle(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.info(`Settle Session`);
            this.logger.trace({ type: "method", method: "settle", params });
            const sharedKey = utils_1.deriveSharedKey(params.self.privateKey, params.peer.publicKey);
            const topic = yield utils_1.sha256(sharedKey);
            const session = {
                topic,
                relay: params.relay,
                sharedKey,
                self: params.self,
                peer: params.peer,
                permissions: params.permissions,
                expiry: params.expiry,
                state: params.state,
            };
            const decryptKeys = {
                sharedKey,
            };
            yield this.settled.set(session.topic, session, { relay: session.relay, decryptKeys });
            return session;
        });
    }
    onResponse(payloadEvent) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { topic, payload } = payloadEvent;
            this.logger.info(`Receiving Session response`);
            this.logger.trace({ type: "method", method: "onResponse", topic, payload });
            const request = payload;
            const pending = yield this.pending.get(topic);
            const pairing = yield this.client.pairing.get(pending.proposal.signal.params.topic);
            const encryptKeys = {
                sharedKey: pairing.sharedKey,
                publicKey: pairing.self.publicKey,
            };
            let errorMessage;
            if (!utils_1.isSessionFailed(request.params)) {
                try {
                    const session = yield this.settle({
                        relay: pending.relay,
                        self: pending.self,
                        peer: request.params.responder,
                        permissions: formatSettledPermissions(pending.proposal.permissions, request.params.responder.publicKey),
                        ttl: pending.proposal.ttl,
                        expiry: request.params.expiry,
                        state: request.params.state,
                    });
                    yield this.pending.update(topic, {
                        status: constants_1.SESSION_STATUS.responded,
                        outcome: {
                            topic: session.topic,
                            relay: session.relay,
                            responder: session.peer,
                            expiry: pairing.expiry,
                            state: session.state,
                        },
                    });
                }
                catch (e) {
                    this.logger.error(e);
                    errorMessage = e.message;
                    yield this.pending.update(topic, {
                        status: constants_1.SESSION_STATUS.responded,
                        outcome: { reason: e.message },
                    });
                }
                const response = typeof errorMessage === "undefined"
                    ? utils_2.formatJsonRpcResult(request.id, true)
                    : utils_2.formatJsonRpcError(request.id, errorMessage);
                yield this.client.relayer.publish(pending.topic, response, {
                    relay: pending.relay,
                    encryptKeys,
                });
            }
            else {
                this.logger.error(request.params.reason);
                yield this.pending.update(topic, {
                    status: constants_1.SESSION_STATUS.responded,
                    outcome: { reason: request.params.reason },
                });
            }
        });
    }
    onAcknowledge(payloadEvent) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { topic, payload } = payloadEvent;
            this.logger.info(`Receiving Session acknowledge`);
            this.logger.trace({ type: "method", method: "onAcknowledge", topic, payload });
            const response = payload;
            const pending = yield this.pending.get(topic);
            if (!utils_1.isSessionResponded(pending))
                return;
            if (utils_2.isJsonRpcError(response) && !utils_1.isSessionFailed(pending.outcome)) {
                yield this.settled.delete(pending.outcome.topic, response.error.message);
            }
            yield this.pending.delete(payloadEvent.topic, constants_1.SESSION_REASONS.acknowledged);
        });
    }
    onMessage(payloadEvent) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { topic, payload } = payloadEvent;
            this.logger.debug(`Receiving Session message`);
            this.logger.trace({ type: "method", method: "onMessage", topic, payload });
            if (utils_2.isJsonRpcRequest(payload)) {
                const request = payload;
                const session = yield this.settled.get(payloadEvent.topic);
                let errorMessage = "";
                switch (request.method) {
                    case constants_1.SESSION_JSONRPC.payload:
                        yield this.onPayload(payloadEvent);
                        break;
                    case constants_1.SESSION_JSONRPC.update:
                        yield this.onUpdate(payloadEvent);
                        break;
                    case constants_1.SESSION_JSONRPC.notification:
                        yield this.onNotification(payloadEvent);
                        break;
                    case constants_1.SESSION_JSONRPC.delete:
                        yield this.settled.delete(session.topic, request.params.reason);
                        break;
                    case constants_1.SESSION_JSONRPC.ping:
                        yield this.send(session.topic, utils_2.formatJsonRpcResult(request.id, false));
                        break;
                    default:
                        errorMessage = `Unknown JSON-RPC Method Requested: ${request.method}`;
                        this.logger.error(errorMessage);
                        yield this.send(session.topic, utils_2.formatJsonRpcError(request.id, errorMessage));
                        break;
                }
            }
            else {
                this.onPayloadEvent(payloadEvent);
            }
        });
    }
    onPayload(payloadEvent) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { topic, payload } = payloadEvent;
            if (utils_2.isJsonRpcRequest(payload)) {
                const { id, params } = payload;
                const request = utils_2.formatJsonRpcRequest(params.request.method, params.request.params, id);
                const session = yield this.settled.get(topic);
                if (!session.permissions.jsonrpc.methods.includes(request.method)) {
                    const errorMessage = `Unauthorized JSON-RPC Method Requested: ${request.method}`;
                    this.logger.error(errorMessage);
                    throw new Error(errorMessage);
                }
                const sessionPayloadEvent = {
                    topic,
                    payload: request,
                    chainId: params.chainId,
                };
                this.logger.debug(`Receiving Session payload`);
                this.logger.trace(Object.assign({ type: "method", method: "onPayload" }, sessionPayloadEvent));
                this.onPayloadEvent(sessionPayloadEvent);
            }
            else {
                const sessionPayloadEvent = {
                    topic,
                    payload,
                };
                this.logger.debug(`Receiving Session payload`);
                this.logger.trace(Object.assign({ type: "method", method: "onPayload" }, sessionPayloadEvent));
                this.onPayloadEvent(sessionPayloadEvent);
            }
        });
    }
    onUpdate(payloadEvent) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { topic, payload } = payloadEvent;
            this.logger.debug(`Receiving Session update`);
            this.logger.trace({ type: "method", method: "onUpdate", topic, payload });
            const request = payloadEvent.payload;
            const session = yield this.settled.get(payloadEvent.topic);
            try {
                yield this.handleUpdate(session, { topic, update: request.params }, { publicKey: session.peer.publicKey });
                const response = utils_2.formatJsonRpcResult(request.id, true);
                yield this.send(session.topic, response);
            }
            catch (e) {
                this.logger.error(e);
                const response = utils_2.formatJsonRpcError(request.id, e.message);
                yield this.send(session.topic, response);
            }
        });
    }
    handleUpdate(session, params, participant) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let update;
            if (typeof params.update.state !== "undefined") {
                const state = session.state;
                if (participant.publicKey !== session.permissions.state.controller.publicKey) {
                    const errorMessage = `Unauthorized session update request`;
                    this.logger.error(errorMessage);
                    throw new Error(errorMessage);
                }
                state.accounts = params.update.state.accounts || state.accounts;
                update = { state };
            }
            else {
                const errorMessage = `Invalid session update request params`;
                this.logger.error(errorMessage);
                throw new Error(errorMessage);
            }
            yield this.settled.update(session.topic, session);
            return update;
        });
    }
    onNotification(event) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const notification = event.payload.params;
            const notificationEvent = {
                topic: event.topic,
                type: notification.type,
                data: notification.data,
            };
            this.logger.info(`Emitting ${constants_1.SESSION_EVENTS.notification}`);
            this.logger.debug({ type: "event", event: constants_1.SESSION_EVENTS.notification, notificationEvent });
            this.events.emit(constants_1.SESSION_EVENTS.notification, notificationEvent);
        });
    }
    shouldIgnorePayloadEvent(payloadEvent) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { topic, payload } = payloadEvent;
            if (!this.settled.subscriptions.has(topic))
                return true;
            let exists = false;
            try {
                exists = yield this.history.exists(topic, payload.id);
            }
            catch (e) {
            }
            return exists;
        });
    }
    onPayloadEvent(payloadEvent) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { topic, payload, chainId } = payloadEvent;
            if (utils_2.isJsonRpcRequest(payload)) {
                if (yield this.shouldIgnorePayloadEvent(payloadEvent))
                    return;
                yield this.history.set(topic, payload, chainId);
            }
            else {
                yield this.history.update(topic, payload);
            }
            this.logger.info(`Emitting ${constants_1.SESSION_EVENTS.payload}`);
            this.logger.debug({ type: "event", event: constants_1.SESSION_EVENTS.payload, data: payloadEvent });
            this.events.emit(constants_1.SESSION_EVENTS.payload, payloadEvent);
        });
    }
    onPendingPayloadEvent(event) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (utils_2.isJsonRpcRequest(event.payload)) {
                switch (event.payload.method) {
                    case constants_1.SESSION_JSONRPC.approve:
                    case constants_1.SESSION_JSONRPC.reject:
                        this.onResponse(event);
                        break;
                    default:
                        break;
                }
            }
            else {
                this.onAcknowledge(event);
            }
        });
    }
    onPendingStatusEvent(event) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const pending = event.data;
            if (utils_1.isSessionResponded(pending)) {
                this.logger.info(`Emitting ${constants_1.SESSION_EVENTS.responded}`);
                this.logger.debug({ type: "event", event: constants_1.SESSION_EVENTS.responded, data: pending });
                this.events.emit(constants_1.SESSION_EVENTS.responded, pending);
                if (!utils_1.isSubscriptionUpdatedEvent(event)) {
                    const pairing = yield this.client.pairing.get(pending.proposal.signal.params.topic);
                    const encryptKeys = {
                        sharedKey: pairing.sharedKey,
                        publicKey: pairing.self.publicKey,
                    };
                    const method = !utils_1.isSessionFailed(pending.outcome)
                        ? constants_1.SESSION_JSONRPC.approve
                        : constants_1.SESSION_JSONRPC.reject;
                    const request = utils_2.formatJsonRpcRequest(method, pending.outcome);
                    yield this.client.relayer.publish(pending.topic, request, {
                        relay: pending.relay,
                        encryptKeys,
                    });
                }
            }
            else {
                this.logger.info(`Emitting ${constants_1.SESSION_EVENTS.proposed}`);
                this.logger.debug({ type: "event", event: constants_1.SESSION_EVENTS.proposed, data: pending });
                this.events.emit(constants_1.SESSION_EVENTS.proposed, pending);
                const request = utils_2.formatJsonRpcRequest(constants_1.SESSION_JSONRPC.propose, pending.proposal);
                yield this.client.pairing.send(pending.proposal.signal.params.topic, request);
            }
        });
    }
    registerEventListeners() {
        this.pending.on(constants_1.SUBSCRIPTION_EVENTS.payload, (payloadEvent) => this.onPendingPayloadEvent(payloadEvent));
        this.pending.on(constants_1.SUBSCRIPTION_EVENTS.created, (createdEvent) => this.onPendingStatusEvent(createdEvent));
        this.pending.on(constants_1.SUBSCRIPTION_EVENTS.updated, (updatedEvent) => this.onPendingStatusEvent(updatedEvent));
        this.settled.on(constants_1.SUBSCRIPTION_EVENTS.payload, (payloadEvent) => this.onMessage(payloadEvent));
        this.settled.on(constants_1.SUBSCRIPTION_EVENTS.created, (createdEvent) => {
            const session = createdEvent.data;
            this.logger.info(`Emitting ${constants_1.SESSION_EVENTS.settled}`);
            this.logger.debug({ type: "event", event: constants_1.SESSION_EVENTS.settled, data: session });
            this.events.emit(constants_1.SESSION_EVENTS.settled, session);
        });
        this.settled.on(constants_1.SUBSCRIPTION_EVENTS.updated, (updatedEvent) => {
            const session = updatedEvent.data;
            this.logger.info(`Emitting ${constants_1.SESSION_EVENTS.updated}`);
            this.logger.debug({ type: "event", event: constants_1.SESSION_EVENTS.updated, data: session });
            this.events.emit(constants_1.SESSION_EVENTS.updated, session);
        });
        this.settled.on(constants_1.SUBSCRIPTION_EVENTS.deleted, (deletedEvent) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const session = deletedEvent.data;
            this.logger.info(`Emitting ${constants_1.SESSION_EVENTS.deleted}`);
            this.logger.debug({ type: "event", event: constants_1.SESSION_EVENTS.deleted, data: session });
            this.events.emit(constants_1.SESSION_EVENTS.deleted, session);
            const request = utils_2.formatJsonRpcRequest(constants_1.SESSION_JSONRPC.delete, {
                reason: deletedEvent.reason,
            });
            yield this.history.delete(session.topic);
            const encryptKeys = {
                sharedKey: session.sharedKey,
                publicKey: session.self.publicKey,
            };
            yield this.client.relayer.publish(session.topic, request, {
                relay: session.relay,
                encryptKeys,
            });
        }));
    }
}
exports.Session = Session;
function formatSettledPermissions(permissions, controllerPublicKey) {
    const controller = { publicKey: controllerPublicKey };
    return Object.assign(Object.assign({}, permissions), { notifications: {
            types: permissions.notifications.types,
            controller,
        }, state: {
            controller,
        } });
}
//# sourceMappingURL=session.js.map