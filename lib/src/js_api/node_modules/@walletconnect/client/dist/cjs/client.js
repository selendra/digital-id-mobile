"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const tslib_1 = require("tslib");
const events_1 = require("events");
const pino_1 = tslib_1.__importDefault(require("pino"));
const keyvaluestorage_1 = tslib_1.__importDefault(require("keyvaluestorage"));
const types_1 = require("@walletconnect/types");
const utils_1 = require("@walletconnect/utils");
const utils_2 = require("@json-rpc-tools/utils");
const pino_utils_1 = require("@pedrouid/pino-utils");
const controllers_1 = require("./controllers");
const constants_1 = require("./constants");
class Client extends types_1.IClient {
    constructor(opts) {
        super(opts);
        this.protocol = "wc";
        this.version = 2;
        this.events = new events_1.EventEmitter();
        this.context = constants_1.CLIENT_CONTEXT;
        const logger = typeof (opts === null || opts === void 0 ? void 0 : opts.logger) !== "undefined" && typeof (opts === null || opts === void 0 ? void 0 : opts.logger) !== "string"
            ? opts.logger
            : pino_1.default(pino_utils_1.getDefaultLoggerOptions({ level: opts === null || opts === void 0 ? void 0 : opts.logger }));
        this.context = (opts === null || opts === void 0 ? void 0 : opts.overrideContext) || this.context;
        this.logger = pino_utils_1.generateChildLogger(logger, this.context);
        this.relayer = new controllers_1.Relayer(this, this.logger, opts === null || opts === void 0 ? void 0 : opts.relayProvider);
        this.storage =
            (opts === null || opts === void 0 ? void 0 : opts.storage) || new keyvaluestorage_1.default(Object.assign(Object.assign({}, constants_1.CLIENT_STORAGE_OPTIONS), opts === null || opts === void 0 ? void 0 : opts.storageOptions));
        this.pairing = new controllers_1.Pairing(this, this.logger);
        this.session = new controllers_1.Session(this, this.logger);
    }
    static init(opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const client = new Client(opts);
            yield client.initialize();
            return client;
        });
    }
    on(event, listener) {
        this.events.on(event, listener);
    }
    once(event, listener) {
        this.events.once(event, listener);
    }
    off(event, listener) {
        this.events.off(event, listener);
    }
    removeListener(event, listener) {
        this.events.removeListener(event, listener);
    }
    connect(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.debug(`Connecting Application`);
            this.logger.trace({ type: "method", method: "connect", params });
            try {
                if (typeof params.pairing === undefined) {
                    this.logger.info("Connecing with existing pairing");
                }
                const pairing = typeof params.pairing === "undefined"
                    ? yield this.pairing.create()
                    : yield this.pairing.get(params.pairing.topic);
                this.logger.trace({ type: "method", method: "connect", pairing });
                const session = yield this.session.create({
                    signal: { method: constants_1.SESSION_SIGNAL_METHOD_PAIRING, params: { topic: pairing.topic } },
                    relay: params.relay || { protocol: constants_1.RELAYER_DEFAULT_PROTOCOL },
                    metadata: params.metadata,
                    permissions: Object.assign(Object.assign({}, params.permissions), { notifications: constants_1.SESSION_EMPTY_PERMISSIONS.notifications }),
                });
                this.logger.debug(`Application Connection Successful`);
                this.logger.trace({ type: "method", method: "connect", session });
                return session;
            }
            catch (e) {
                this.logger.debug(`Application Connection Failure`);
                this.logger.error(e);
                throw e;
            }
        });
    }
    pair(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.debug(`Pairing`);
            this.logger.trace({ type: "method", method: "pair", params });
            const proposal = formatPairingProposal(params.uri);
            const pending = yield this.pairing.respond({ approved: true, proposal });
            if (!utils_1.isPairingResponded(pending))
                return;
            if (utils_1.isPairingFailed(pending.outcome)) {
                this.logger.debug(`Pairing Failure`);
                this.logger.trace({ type: "method", method: "pair", outcome: pending.outcome });
                return;
            }
            this.logger.debug(`Pairing Success`);
            this.logger.trace({ type: "method", method: "pair", pending });
        });
    }
    approve(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.debug(`Approving Session Proposal`);
            this.logger.trace({ type: "method", method: "approve", params });
            if (typeof params.response === "undefined") {
                const errorMessage = "Response is required for approved session proposals";
                this.logger.error(errorMessage);
                throw new Error(errorMessage);
            }
            const pending = yield this.session.respond({
                approved: true,
                proposal: params.proposal,
                response: params.response || constants_1.SESSION_EMPTY_RESPONSE,
            });
            if (!utils_1.isSessionResponded(pending)) {
                const errorMessage = "No Session Response found in pending proposal";
                this.logger.error(errorMessage);
                throw new Error(errorMessage);
            }
            if (utils_1.isSessionFailed(pending.outcome)) {
                this.logger.debug(`Session Proposal Approval Failure`);
                this.logger.trace({ type: "method", method: "approve", outcome: pending.outcome });
                throw new Error(pending.outcome.reason);
            }
            this.logger.debug(`Session Proposal Approval Success`);
            this.logger.trace({ type: "method", method: "approve", pending });
            return this.session.get(pending.outcome.topic);
        });
    }
    reject(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.debug(`Rejecting Session Proposal`);
            this.logger.trace({ type: "method", method: "reject", params });
            const pending = yield this.session.respond({
                approved: false,
                proposal: params.proposal,
                response: constants_1.SESSION_EMPTY_RESPONSE,
            });
            this.logger.debug(`Session Proposal Response Success`);
            this.logger.trace({ type: "method", method: "reject", pending });
        });
    }
    update(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.session.update(params);
        });
    }
    notify(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.session.notify(params);
        });
    }
    request(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.session.request(params);
        });
    }
    respond(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.session.send(params.topic, params.response);
        });
    }
    disconnect(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.debug(`Disconnecting Application`);
            this.logger.trace({ type: "method", method: "disconnect", params });
            yield this.session.delete(params);
        });
    }
    onPairingPayload(payload) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (utils_2.isJsonRpcRequest(payload)) {
                if (payload.method === constants_1.SESSION_JSONRPC.propose) {
                    this.logger.info(`Emitting ${constants_1.CLIENT_EVENTS.session.proposal}`);
                    this.logger.debug({
                        type: "event",
                        event: constants_1.CLIENT_EVENTS.session.proposal,
                        data: payload.params,
                    });
                    this.events.emit(constants_1.CLIENT_EVENTS.session.proposal, payload.params);
                }
            }
        });
    }
    onPairingSettled(pairing) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const metadata = utils_1.getPairingMetadata();
            if (typeof metadata === "undefined")
                return;
            const update = { peer: { metadata } };
            this.pairing.update({ topic: pairing.topic, update });
        });
    }
    initialize() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.trace(`Initialized`);
            try {
                yield this.relayer.init();
                yield this.pairing.init();
                yield this.session.init();
                this.registerEventListeners();
                this.logger.info(`Client Initilization Success`);
            }
            catch (e) {
                this.logger.info(`Client Initilization Failure`);
                this.logger.error(e);
                throw e;
            }
        });
    }
    registerEventListeners() {
        this.pairing.on(constants_1.PAIRING_EVENTS.proposed, (pending) => {
            this.logger.info(`Emitting ${constants_1.CLIENT_EVENTS.pairing.proposal}`);
            this.logger.debug({
                type: "event",
                event: constants_1.CLIENT_EVENTS.pairing.proposal,
                data: pending.proposal,
            });
            this.events.emit(constants_1.CLIENT_EVENTS.pairing.proposal, pending.proposal);
        });
        this.pairing.on(constants_1.PAIRING_EVENTS.settled, (pairing) => {
            this.logger.info(`Emitting ${constants_1.CLIENT_EVENTS.pairing.created}`);
            this.logger.debug({
                type: "event",
                event: constants_1.CLIENT_EVENTS.pairing.created,
                data: pairing,
            });
            this.events.emit(constants_1.CLIENT_EVENTS.pairing.created, pairing);
            this.onPairingSettled(pairing);
        });
        this.pairing.on(constants_1.PAIRING_EVENTS.updated, (pairing) => {
            this.logger.info(`Emitting ${constants_1.CLIENT_EVENTS.pairing.updated}`);
            this.logger.debug({
                type: "event",
                event: constants_1.CLIENT_EVENTS.pairing.updated,
                data: pairing,
            });
            this.events.emit(constants_1.CLIENT_EVENTS.pairing.updated, pairing);
        });
        this.pairing.on(constants_1.PAIRING_EVENTS.deleted, (pairing) => {
            this.logger.info(`Emitting ${constants_1.CLIENT_EVENTS.pairing.deleted}`);
            this.logger.debug({
                type: "event",
                event: constants_1.CLIENT_EVENTS.pairing.deleted,
                data: pairing,
            });
            this.events.emit(constants_1.CLIENT_EVENTS.pairing.deleted, pairing);
        });
        this.pairing.on(constants_1.PAIRING_EVENTS.payload, (payloadEvent) => {
            this.onPairingPayload(payloadEvent.payload);
        });
        this.session.on(constants_1.SESSION_EVENTS.proposed, (pending) => {
            this.logger.info(`Emitting ${constants_1.CLIENT_EVENTS.session.proposal}`);
            this.logger.debug({
                type: "event",
                event: constants_1.CLIENT_EVENTS.session.proposal,
                data: pending.proposal,
            });
            this.events.emit(constants_1.CLIENT_EVENTS.session.proposal, pending.proposal);
        });
        this.session.on(constants_1.SESSION_EVENTS.settled, (session) => {
            this.logger.info(`Emitting ${constants_1.CLIENT_EVENTS.session.created}`);
            this.logger.debug({ type: "event", event: constants_1.CLIENT_EVENTS.session.created, data: session });
            this.events.emit(constants_1.CLIENT_EVENTS.session.created, session);
        });
        this.session.on(constants_1.SESSION_EVENTS.updated, (session) => {
            this.logger.info(`Emitting ${constants_1.CLIENT_EVENTS.session.updated}`);
            this.logger.debug({ type: "event", event: constants_1.CLIENT_EVENTS.session.updated, data: session });
            this.events.emit(constants_1.CLIENT_EVENTS.session.updated, session);
        });
        this.session.on(constants_1.SESSION_EVENTS.deleted, (session) => {
            this.logger.info(`Emitting ${constants_1.CLIENT_EVENTS.session.deleted}`);
            this.logger.debug({ type: "event", event: constants_1.CLIENT_EVENTS.session.deleted, data: session });
            this.events.emit(constants_1.CLIENT_EVENTS.session.deleted, session);
        });
        this.session.on(constants_1.SESSION_EVENTS.payload, (payloadEvent) => {
            this.logger.info(`Emitting ${constants_1.CLIENT_EVENTS.session.payload}`);
            this.logger.debug({
                type: "event",
                event: constants_1.CLIENT_EVENTS.session.payload,
                data: payloadEvent,
            });
            this.events.emit(constants_1.CLIENT_EVENTS.session.payload, payloadEvent);
        });
        this.session.on(constants_1.SESSION_EVENTS.notification, (notificationEvent) => {
            this.logger.info(`Emitting ${constants_1.CLIENT_EVENTS.session.notification}`);
            this.logger.debug({
                type: "event",
                event: constants_1.CLIENT_EVENTS.session.notification,
                data: notificationEvent,
            });
            this.events.emit(constants_1.CLIENT_EVENTS.session.notification, notificationEvent);
        });
    }
}
exports.Client = Client;
function formatPairingProposal(uri) {
    const uriParams = utils_1.parseUri(uri);
    return {
        topic: uriParams.topic,
        relay: uriParams.relay,
        proposer: { publicKey: uriParams.publicKey },
        signal: { method: constants_1.PAIRING_SIGNAL_METHOD_URI, params: { uri } },
        permissions: { jsonrpc: { methods: [constants_1.SESSION_JSONRPC.propose] } },
        ttl: constants_1.PAIRING_DEFAULT_TTL,
    };
}
//# sourceMappingURL=client.js.map