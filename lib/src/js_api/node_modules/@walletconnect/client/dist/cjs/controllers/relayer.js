"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Relayer = void 0;
const tslib_1 = require("tslib");
const events_1 = require("events");
const pino_utils_1 = require("@pedrouid/pino-utils");
const types_1 = require("@walletconnect/types");
const relay_provider_1 = require("relay-provider");
const utils_1 = require("@walletconnect/utils");
const enc_utils_1 = require("enc-utils");
const utils_2 = require("@json-rpc-tools/utils");
const provider_1 = require("@json-rpc-tools/provider");
const safe_json_utils_1 = require("safe-json-utils");
const constants_1 = require("../constants");
class Relayer extends types_1.IRelayer {
    constructor(client, logger, provider) {
        super(client, logger);
        this.client = client;
        this.logger = logger;
        this.events = new events_1.EventEmitter();
        this.context = constants_1.RELAYER_CONTEXT;
        this.logger = pino_utils_1.generateChildLogger(logger, this.context);
        this.provider = this.setProvider(provider);
        this.registerEventListeners();
    }
    get connected() {
        return this.provider.connection.connected;
    }
    init() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.trace(`Initialized`);
            yield this.provider.connect();
        });
    }
    publish(topic, payload, opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.debug(`Publishing Payload`);
            this.logger.trace({ type: "method", method: "publish", params: { topic, payload, opts } });
            try {
                const protocol = (opts === null || opts === void 0 ? void 0 : opts.relay.protocol) || constants_1.RELAYER_DEFAULT_PROTOCOL;
                const msg = safe_json_utils_1.safeJsonStringify(payload);
                const message = (opts === null || opts === void 0 ? void 0 : opts.encryptKeys) ? yield utils_1.encrypt(Object.assign(Object.assign({}, opts.encryptKeys), { message: msg }))
                    : enc_utils_1.utf8ToHex(msg);
                const jsonRpc = getRelayProtocolJsonRpc(protocol);
                const request = {
                    method: jsonRpc.publish,
                    params: {
                        topic,
                        message,
                        ttl: (opts === null || opts === void 0 ? void 0 : opts.ttl) || constants_1.RELAYER_DEFAULT_PUBLISH_TTL,
                    },
                };
                this.logger.info(`Outgoing Relay Payload`);
                this.logger.debug({ type: "payload", direction: "outgoing", request });
                yield this.provider.request(request);
                this.logger.debug(`Successfully Published Payload`);
                this.logger.trace({ type: "method", method: "publish", request });
            }
            catch (e) {
                this.logger.debug(`Failed to Publish Payload`);
                this.logger.error(e);
                throw e;
            }
        });
    }
    subscribe(topic, listener, opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.debug(`Subscribing Topic`);
            this.logger.trace({ type: "method", method: "subscribe", params: { topic, opts } });
            try {
                const protocol = (opts === null || opts === void 0 ? void 0 : opts.relay.protocol) || constants_1.RELAYER_DEFAULT_PROTOCOL;
                const jsonRpc = getRelayProtocolJsonRpc(protocol);
                const request = {
                    method: jsonRpc.subscribe,
                    params: {
                        topic,
                    },
                };
                this.logger.info(`Outgoing Relay Payload`);
                this.logger.debug({ type: "payload", direction: "outgoing", request });
                const id = yield this.provider.request(request);
                this.events.on(id, ({ message }) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    const payload = safe_json_utils_1.safeJsonParse((opts === null || opts === void 0 ? void 0 : opts.decryptKeys) ? yield utils_1.decrypt(Object.assign(Object.assign({}, opts.decryptKeys), { encrypted: message }))
                        : enc_utils_1.hexToUtf8(message));
                    listener(payload);
                }));
                this.logger.debug(`Successfully Subscribed Topic`);
                this.logger.trace({ type: "method", method: "subscribe", request });
                return id;
            }
            catch (e) {
                this.logger.debug(`Failed to Subscribe Topic`);
                this.logger.error(e);
                throw e;
            }
        });
    }
    unsubscribe(id, opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.debug(`Unsubscribing Topic`);
            this.logger.trace({ type: "method", method: "unsubscribe", params: { id, opts } });
            try {
                const protocol = (opts === null || opts === void 0 ? void 0 : opts.relay.protocol) || constants_1.RELAYER_DEFAULT_PROTOCOL;
                const jsonRpc = getRelayProtocolJsonRpc(protocol);
                const request = {
                    method: jsonRpc.unsubscribe,
                    params: {
                        id,
                    },
                };
                this.logger.info(`Outgoing Relay Payload`);
                this.logger.debug({ type: "payload", direction: "outgoing", request });
                yield this.provider.request(request);
                this.events.removeAllListeners(id);
                this.logger.debug(`Successfully Unsubscribed Topic`);
                this.logger.trace({ type: "method", method: "unsubscribe", request });
            }
            catch (e) {
                this.logger.debug(`Failed to Unsubscribe Topic`);
                this.logger.error(e);
                throw e;
            }
        });
    }
    on(event, listener) {
        this.events.on(event, listener);
    }
    once(event, listener) {
        this.events.once(event, listener);
    }
    off(event, listener) {
        this.events.off(event, listener);
    }
    removeListener(event, listener) {
        this.events.removeListener(event, listener);
    }
    onPayload(payload) {
        this.logger.info(`Incoming Relay Payload`);
        this.logger.debug({ type: "payload", direction: "incoming", payload });
        if (utils_2.isJsonRpcRequest(payload)) {
            if (payload.method.endsWith("_subscription")) {
                const event = payload.params;
                this.events.emit(event.id, event.data);
                const response = utils_2.formatJsonRpcResult(payload.id, true);
                this.provider.connection.send(response);
            }
        }
    }
    setProvider(provider) {
        this.logger.debug(`Setting Relay Provider`);
        this.logger.trace({ type: "method", method: "setProvider", provider: provider === null || provider === void 0 ? void 0 : provider.toString() });
        const rpcUrl = utils_1.formatRelayRpcUrl(this.client.protocol, this.client.version, typeof provider === "string" ? provider : constants_1.RELAYER_DEFAULT_RPC_URL);
        return typeof provider !== "string" && typeof provider !== "undefined"
            ? provider
            : new provider_1.JsonRpcProvider(rpcUrl);
    }
    registerEventListeners() {
        this.provider.on("payload", (payload) => this.onPayload(payload));
        this.provider.on("connect", () => this.events.emit("connect"));
        this.provider.on("disconnect", () => {
            this.events.emit("disconnect");
            this.provider.connect();
        });
        this.provider.on("error", e => this.events.emit("error", e));
    }
}
exports.Relayer = Relayer;
function getRelayProtocolJsonRpc(protocol) {
    const jsonrpc = relay_provider_1.RELAY_JSONRPC[protocol];
    if (typeof jsonrpc === "undefined") {
        throw new Error(`Relay Protocol not supported: ${protocol}`);
    }
    return jsonrpc;
}
//# sourceMappingURL=relayer.js.map