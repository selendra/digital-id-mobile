// Copyright 2017-2022 @polkadot/api-contract authors & contributors
// SPDX-License-Identifier: Apache-2.0
import { map } from 'rxjs';
import { SubmittableResult } from '@polkadot/api';
import { BN, BN_HUNDRED, BN_ONE, BN_ZERO, bnToBn, isFunction, isUndefined, logger } from '@polkadot/util';
import { applyOnEvent, extractOptions, isOptions } from "../util.js";
import { Base } from "./Base.js";
import { withMeta } from "./util.js";
// As per Rust, 5 * GAS_PER_SEC
const MAX_CALL_GAS = new BN(5000000000000).isub(BN_ONE);
const ERROR_NO_CALL = 'Your node does not expose the contracts.call RPC. This is most probably due to a runtime configuration.';
const l = logger('Contract');

function createQuery(meta, fn) {
  return withMeta(meta, (origin, options, ...params) => isOptions(options) ? fn(origin, options, params) : fn(origin, ...extractOptions(options, params)));
}

function createTx(meta, fn) {
  return withMeta(meta, (options, ...params) => isOptions(options) ? fn(options, params) : fn(...extractOptions(options, params)));
}

export class ContractSubmittableResult extends SubmittableResult {
  constructor(result, contractEvents) {
    super(result);
    this.contractEvents = contractEvents;
  }

}
export class Contract extends Base {
  /**
   * @description The on-chain address for this contract
   */
  #query = {};
  #tx = {};

  constructor(api, abi, address, decorateMethod) {
    super(api, abi, decorateMethod);
    this.address = this.registry.createType('AccountId', address);
    this.abi.messages.forEach(m => {
      if (isUndefined(this.#tx[m.method])) {
        this.#tx[m.method] = createTx(m, (o, p) => this.#exec(m, o, p));
      }

      if (isUndefined(this.#query[m.method])) {
        this.#query[m.method] = createQuery(m, (f, o, p) => this.#read(m, o, p).send(f));
      }
    });
  }

  get hasRpcContractsCall() {
    var _this$api$rx$rpc$cont;

    return isFunction((_this$api$rx$rpc$cont = this.api.rx.rpc.contracts) === null || _this$api$rx$rpc$cont === void 0 ? void 0 : _this$api$rx$rpc$cont.call);
  }

  get query() {
    if (!this.hasRpcContractsCall) {
      throw new Error(ERROR_NO_CALL);
    }

    return this.#query;
  }

  get tx() {
    return this.#tx;
  }

  #getGas = (_gasLimit, isCall = false) => {
    const gasLimit = bnToBn(_gasLimit);
    return gasLimit.lte(BN_ZERO) ? isCall ? MAX_CALL_GAS : (this.api.consts.system.blockWeights ? this.api.consts.system.blockWeights.maxBlock : this.api.consts.system.maximumBlockWeight).muln(64).div(BN_HUNDRED) : gasLimit;
  };
  #exec = (messageOrId, {
    gasLimit = BN_ZERO,
    storageDepositLimit = null,
    value = BN_ZERO
  }, params) => {
    const hasStorageDeposit = this.api.tx.contracts.call.meta.args.length === 5;
    const gas = this.#getGas(gasLimit);
    const encParams = this.abi.findMessage(messageOrId).toU8a(params);
    const tx = hasStorageDeposit ? this.api.tx.contracts.call(this.address, value, gas, storageDepositLimit, encParams) // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore old style without storage deposit
    : this.api.tx.contracts.call(this.address, value, gas, encParams);
    return tx.withResultTransform(result => // ContractEmitted is the current generation, ContractExecution is the previous generation
    new ContractSubmittableResult(result, applyOnEvent(result, ['ContractEmitted', 'ContractExecution'], records => records.map(({
      event: {
        data: [, data]
      }
    }) => {
      try {
        return this.abi.decodeEvent(data);
      } catch (error) {
        l.error(`Unable to decode contract event: ${error.message}`);
        return null;
      }
    }).filter(decoded => !!decoded))));
  };
  #read = (messageOrId, {
    gasLimit = BN_ZERO,
    storageDepositLimit = null,
    value = BN_ZERO
  }, params) => {
    if (!this.hasRpcContractsCall) {
      throw new Error(ERROR_NO_CALL);
    }

    const message = this.abi.findMessage(messageOrId);
    return {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
      send: this._decorateMethod(origin => {
        const hasStorageDeposit = this.api.tx.contracts.call.meta.args.length === 5;
        const inputData = message.toU8a(params);
        const rpc = hasStorageDeposit ? this.api.rx.rpc.contracts.call({
          dest: this.address,
          gasLimit: this.#getGas(gasLimit, true),
          inputData,
          origin,
          storageDepositLimit,
          value
        }) : this.api.rx.rpc.contracts.call({
          dest: this.address,
          gasLimit: this.#getGas(gasLimit, true),
          inputData,
          origin,
          value
        });

        const mapFn = ({
          debugMessage,
          gasConsumed,
          gasRequired,
          result,
          storageDeposit
        }) => ({
          debugMessage,
          gasConsumed,
          gasRequired: gasRequired && !gasRequired.isZero() ? gasRequired : gasConsumed,
          output: result.isOk && message.returnType ? this.abi.registry.createTypeUnsafe(message.returnType.lookupName || message.returnType.type, [result.asOk.data.toU8a(true)], {
            isPedantic: true
          }) : null,
          result,
          storageDeposit
        });

        return rpc.pipe(map(mapFn));
      })
    };
  };
}
export function extendContract(type, decorateMethod) {
  return class extends Contract {
    static __ContractType = type;

    constructor(api, abi, address) {
      super(api, abi, address, decorateMethod);
    }

  };
}